#!groovy

def dockerImage = ''

pipeline {
  environment {
    REGISTRY = "cmudb/performance-storage-service"
    REGISTRY_CREDENTIAL = 'cmudb-dockerhub'
    VERSION = "1.0.1"
    TIMESCALE_IMAGE = 'timescale/timescaledb:latest-pg12'
  }
  agent {
    label 'docker'
  }
  stages{
    stage('Checkout'){
      steps{
        checkout scm
      }
    }

    stage('Build'){
      steps{
        dir('performance-storage-service'){
          script{
            dockerImage = docker.build REGISTRY + ":${VERSION}"
          }
        }
      }
    }

    stage('Test'){
      steps{
        script{
          dir('performance-storage-service'){
            // docker.withRegistry('', REGISTRY_CREDENTIAL) {
            //   sh "docker ps"
              sh "mkdir reports"
              docker.image(TIMESCALE_IMAGE).withRun("-e POSTGRES_PASSWORD=password -p 5432:5432 -v ${WORKSPACE}/reports/:/reports/") { ts ->
                /* Wait until timescale service is up */
                sh """
                  sudo apt-get update
                  sudo apt-get install postgresql-client -y
                  until pg_isready -d postgres -h 127.0.0.1 -p 5432 -U postgres > 1; do
                  echo "Waiting for postgres server"
                  sleep 1
                done"""
                sh "mkdir /reports"
                dockerImage.inside("--net=host -e SECRET_KEY=shhh -v /reports/:/performance-storage-service/reports/ --entrypoint=''" ){
                  sh 'python manage.py jenkins --enable-coverage --coverage-rcfile=.coveragerc'
                }
              }
            // }
          }
        }
      }
      post{
        always{
          sh "ls reports"
          xunit (
              thresholds: [ skipped(failureThreshold: '0'), failed(failureThreshold: '0') ],
              tools: [ JUnit(pattern: 'reports/junit.xml') ]
          )
        }
      }
    }

    stage('Publish'){
      when{
        branch 'test'
      }
      steps{
        script{
          dir('performance-storage-service'){
            docker.withRegistry('', REGISTRY_CREDENTIAL) {
                dockerImage.push("latest")
                dockerImage.push("${VERSION}")
            }
          }
        }
      }
    }
  }

  post {
    cleanup{
      script{
        if (env.BRANCH_NAME == 'test') {
          echo "removing docker image"
          sh "docker rmi ${REGISTRY}:${VERSION}"
        }
        echo "stopping timescaledb if it wasn't already stopped"
        sh "docker stop timescaledb || true"
        echo "removing timescale image"
        sh "docker rmi ${TIMESCALE_IMAGE} -f"
        echo "deleting directory"
        deleteDir()
      }
    }
  }
}
